{"meta":{"title":"花花世界博客","subtitle":"逗比的小码农","description":"我思故我在","author":"花花世界","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-12-13T05:08:38.157Z","updated":"2017-12-13T05:08:38.157Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 - arao'blog"},{"title":"类别","date":"2017-12-13T08:07:17.000Z","updated":"2017-12-14T06:37:06.718Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-12-14T06:36:46.839Z","updated":"2017-12-14T06:36:46.839Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于me一只学习Android的小菜鸟，欢迎分享知识。 From QQ：2414923649Email: 2414923649@qq.com"},{"title":"标签云","date":"2017-12-14T06:34:16.000Z","updated":"2017-12-14T06:37:29.673Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"##标签三大所大所 大四的"}],"posts":[{"title":"Kotlin+MVP+Dagger2+Retrofit","slug":"Kotlin_mvp_dagger2_retrofit","date":"2017-12-12T11:03:25.387Z","updated":"2017-12-14T07:13:00.880Z","comments":true,"path":"2017/12/12/Kotlin_mvp_dagger2_retrofit/","link":"","permalink":"http://yoursite.com/2017/12/12/Kotlin_mvp_dagger2_retrofit/","excerpt":"","text":"上一篇我们学习了anko库的使用，到这里我们来做一个简单的小项目吧！那使用什么架构来写呢，这里我们使用Kotlin+dagger2+retrofit+MVP架构来撸码 在学习这篇文章之前需要掌握下面的知识，如下： dagger2 http://www.jianshu.com/p/39d1df6c877d retrofit http://www.jianshu.com/p/308f3c54abdd API http://gank.io/api ##正文因为项目中用的Dagger2比较多，这里来讲解一下项目中用到的几个注解，更多的详情可以看上面的地址 Component:组件、管理器、注入器功能就是将类中使用@Inject标记的属性和在对应属性类中使用@Inject标记的构造方法，然后将它们关联起来。 而如果构造方法需要参数，或者我们没法再需要注入的对象的构造方法加入@Inject注解的时候就需要使用Module 该注解里面的参数有两个，一个是设置modules所关联的Module类，第二个是dependency所依赖的Component Module：提供者、依赖对象工厂功能是与被@Inject标记的构造方法一样提供生成依赖的对象 因为对于第三方库我们没有办法将它的构造方法加入@Inject标记，这时候我们需要使用Module生成，并提供@provide注解，Component会去查找Module类中@provide的方法获取到对象并通过component返回目标类需要的对象并注入到目标类 Qualifier:限定符功能是在同一纬度下存在多个依赖对象的提供方式(多个构造方法)，则会迷失。这时，可以使用Qualifier 提供依赖对象有两种方式 （1）通过使用Inject注解标注的构造函数来创建 （2）通过工厂模式的Module来创建 如果一个依赖对象以上两种方式都能够提供，它会优先使用Module。Qualifier有一个@Named 指定相同的参数和自定义Qualifier注解一样的效果 @Qualifier @Documented @Retention(RUNTIME) public @interface Named { /** The name. */ String value() default &quot;&quot;; } Scope:作用域 管理创建的类实例的生命周期。 可以通过Scope来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。 Scope本身没有制定生命周期的能力，它的存在一是为了可读性,二是更好的管理Component和Module的关系 如果你想了解Dagger2具体调用的流程可以查看 接下来我们开始看一下要做的小项目的效果图 ok,项目比较low，废话不多说，开始我们撸代码时间 我是这样分包的 在项目中我定义了一个全局的Component类 @Singleton @Component(modules = arrayOf(DataSourceModule::class)) //注入器对象提供工厂 interface AppComponent{ /** * 全局注入器能够提供的对象 */ fun dataManager(): DataManager } 这个类为DataSourceModule用来提供DataManager对象的生成，使用DataManager来对网络请求会去查询DataSourceModule类中去找生成DataManager对象的方法 @Module class DataSourceModule { @Singleton @Provides fun provideGankService(): GankService { return Retrofit.Builder().addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl(BASE_URL).build().create(GankService::class.java) } @Singleton @Local @Provides fun provideLocal(): IDataSource{ return LocalDataSource() } @Singleton @Remote @Provides fun provideRemote(service: GankService): IDataSource { return RemoteDataSource(service) } @Singleton @Provides fun provideDataManager(@Remote remote: IDataSource, @Local local: IDataSource): DataManager { return DataManager(remote,local) } } 这里推荐使用provide开头，在方法参数里面我有定义两个注解Remote和Local用来区分对应哪个一个IDataSource @Qualifier annotation class Remote provideGankService方法里面的写法使用了Gson转换用于将json转化为对象、Rxjava回调用来对网络请求的结果做不同的处理 然后我们在来看一下DataManager类 fun getWelfareList(page: Int): Flowable&lt;WelfareEntity&gt; { return remote.getWelfareList(page).onErrorResumeNext(local.getWelfareList(page)) } 主要是定义相应的规则，先在网络请求获取，当失败的时候获取本地的数据 ok,前期的工作准备完毕，为了更好去使用APPComponent，我们在Application自定一个单例 class MyApplication: Application(){ /** * 提供全局注入器的获得 */ lateinit private var appComponent: AppComponent companion object { lateinit var app: MyApplication fun getApplication(): MyApplication{ return app } } override fun onCreate() { super.onCreate() app = this appComponent = DaggerAppComponent.builder().dataSourceModule(DataSourceModule()).build() } fun getAppComponent(): AppComponent = appComponent } 开始我们的主界面，当然这个项目也就一个Activity，既然是MVP就少不了Persenter @Inject lateinit var presenter: MainPersenter 使用Inject注解来自动去创建MainPersenter对象，然后定义MainAppComponent @ActivityScope @Component(modules = arrayOf(MainActivityModule::class),dependencies = arrayOf(AppComponent::class)) interface MainAppComponent{ fun inject(activity: MainActivity) } 这里对APPComponent进行了依赖，因为在MainPersenter类里面使用到了DataManager的对象 @Module class MainActivityModule(val view: MainActivity){ @ActivityScope @Provides fun provide1Presenter(dataManager: DataManager): MainPersenter{ return MainPersenter(view,dataManager) } } 然后我们在来看一下MainPersenter class MainPersenter(val view: MainViews, val dataManager: DataManager) { //福利 fun getWelfarmList(page: Int) { dataManager.getWelfareList(page) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnSubscribe { view.startLoading() } .doOnError { view.stopLoading() } .subscribe { view.stopLoading() view.showWefareList(it.results) } } 在这个类中主要是使用DataManager的对象用来获取数据并针对获取成功和失败调用View层的方法 最后我们需要初始化Dagger2注入器 //初始化Dagger2注入器 DaggerMainAppComponent.builder() .appComponent(MyApplication.getApplication().getAppComponent()) .mainActivityModule(MainActivityModule(this)) .build().inject(this) 另外在写生成ItemView的时候写了两种方式，这里也一并贴出来和大家一起分享 第一种使用with表达式 val view = with(context){ verticalLayout { gravity = Gravity.CENTER_HORIZONTAL imageView { id = R.id.welfare_item_iv imageResource = R.mipmap.ic_launcher scaleType = ImageView.ScaleType.FIT_XY lparams { height = dip(250) width = matchParent leftMargin = dip(20) rightMargin = dip(20) topMargin = dip(15) bottomMargin = dip(15) } } } } 当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果 class RecyclerUI: AnkoComponent&lt;AndroidAdapter&gt;{ override fun createView(ui: AnkoContext&lt;AndroidAdapter&gt;): View = with(ui){ verticalLayout { orientation = LinearLayout.HORIZONTAL lparams { topMargin = dip(10) leftMargin = dip(15) rightMargin = dip(15) bottomMargin = dip(10) } imageView { id = R.id.android_item_iv imageResource = R.mipmap.android_icon lparams { width = dip(90) height = dip(90) } } verticalLayout { textView { id = R.id.android_item_tv1 textSize = 18.toFloat() } textView { id = R.id.android_item_tv2 textSize = 16.toFloat() textColor = Color.RED } } } } } 至此，小项目的讲解就结束了。 ```坚持总会有结果，总会有收获的","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}]},{"title":"Kotlin_anko的简单使用","slug":"Kotlin_anko的简单使用","date":"2017-12-12T11:03:25.384Z","updated":"2017-12-14T07:12:54.506Z","comments":true,"path":"2017/12/12/Kotlin_anko的简单使用/","link":"","permalink":"http://yoursite.com/2017/12/12/Kotlin_anko的简单使用/","excerpt":"","text":"上一篇我们介绍了Anko库的使用，这里我们用Anko来做一个简单的RecyclerView列表 废话不说，直接撸代码 ##Start首先我们使用Anko在代码里面写一个RecyclerView，看代码 verticalLayout { recyclerView { id = R.id.main_rv //设置参数 anko为Activity扩展了act的字段 layoutManager = LinearLayoutManager(act) //layoutManager = LinearLayoutManager (this@MainActivity) padding = dip(20) adapter = this@MainActivity.adapter } } 接下来我们定义一个Adapter class MyAdapter(val ctx: Context, val items: ArrayList&lt;Resp&gt;): RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt;(){ override fun onBindViewHolder(holder: MyViewHolder?, position: Int) { val resp: Resp = items.get(position) Glide.with(ctx).load(resp.owner.avatar_url).into(holder?.iv) //？.代表holder可为空 holder?.tv1?.text = resp.name holder?.tv2?.text = resp.full_name } override fun getItemCount(): Int = items.size override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): MyViewHolder { //with : 在给定对象上调用lambda中的所有方法 val view = with(ctx){ verticalLayout { orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView { id = R.id.iv lparams { rightMargin = dip(20) leftMargin = dip(15) width = dip(80) height = dip(80) } //设置默认图片 imageResource = R.mipmap.ic_launcher } verticalLayout { orientation = LinearLayout.VERTICAL textView { id = R.id.tv1 textSize = 14f textColor = 0xff0000.opaque } textView { id = R.id.tv2 textSize = 16f textColor = 0x000000 } } } } val holder = MyViewHolder(view) return holder } class MyViewHolder(itemView: View): RecyclerView.ViewHolder(itemView){ //在给定的View上查找指定的id视图 val iv: ImageView = itemView.find(R.id.iv) val tv1: TextView = itemView.find(R.id.tv1) val tv2: TextView = itemView.find(R.id.tv2) } } 是不是很炫酷，当然这样写感觉代码太多了，我们需要将生成布局的代码单独使用一个类，我们可以定义一个类来继承AnkoComponent来写独立的一个布局，如果安装插件还可以预览界面的效果，具体的代码如下： class RecycleUI : AnkoComponent&lt;MyAdapter&gt; { override fun createView(ui: AnkoContext&lt;MyAdapter&gt;): View = with(ui) { verticalLayout { orientation = LinearLayout.HORIZONTAL gravity = Gravity.CENTER_VERTICAL imageView { id = R.id.iv lparams { rightMargin = dip(12) width = dip(80) height = dip(80) } } verticalLayout { textView { id = R.id.tv1 } textView { id = R.id.tv2 } } } } } 这里我们也是使用with来生成相应的View视图 最后便是请求数据更新Adapter的操作了 async(kotlinx.coroutines.experimental.android.UI){ //启动子线程 val data: Deferred&lt;ArrayList&lt;Resp&gt;&gt; = bg{ //读取assets里面的数据 val input = assets.open(&quot;data.json&quot;) val bytes = input.readBytes() input.close() //将得到的json串解析成对象并返回给data Gson().fromJson&lt;ArrayList&lt;Resp&gt;&gt;(String(bytes), getType&lt;ArrayList&lt;Resp&gt;&gt;()) } items.clear() items.addAll(data.await()) //这里通过调用await方法会一直等待后台的执行，当执行完毕将赋值给item集合，并更新适配器 adapter.notifyDataSetChanged()","categories":[],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://yoursite.com/tags/Kotlin/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-12T09:41:52.342Z","updated":"2017-12-12T09:41:52.342Z","comments":true,"path":"2017/12/12/hello-world/","link":"","permalink":"http://yoursite.com/2017/12/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}